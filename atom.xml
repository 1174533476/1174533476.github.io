<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JellyGoGo Blog</title>
  <subtitle>扯淡,发呆,思考之处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jellygogo.com/"/>
  <updated>2016-04-07T08:47:31.170Z</updated>
  <id>http://jellygogo.com/</id>
  
  <author>
    <name>Gordon Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MRunit combiner partitioner</title>
    <link href="http://jellygogo.com/2016/04/07/MRunit_combiner_partitioner/"/>
    <id>http://jellygogo.com/2016/04/07/MRunit_combiner_partitioner/</id>
    <published>2016-04-07T15:50:55.000Z</published>
    <updated>2016-04-07T08:47:31.170Z</updated>
    
    <content type="html">&lt;p&gt;在maven中使用MRunit测试框架搭建了个mapreduce程序,里面使用了combiner和partitioner&lt;br&gt;并使用了 org.apache.hadoop.util.Tool&lt;br&gt;实现了找出对应年份的最大值,&lt;br&gt;        //数据样例&lt;br&gt;        1995 65&lt;br&gt;        1965 21&lt;br&gt;        1995 62&lt;br&gt;为了验证使用combiner和不适用combiner的不同,所以写了个生成数据的小程序&lt;br&gt;    package com.jellygogo.basejava;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
public class MaxNumOfYearTest implements Runnable{
    public static final int ONEFILEMAXLINE = 100000;
    public static final int STARTFILE = 0 ;
    public static final int ENDFILE = 1;
    public int num;
    public MaxNumOfYearTest(int num) {
        super();
        this.num = num;
    }
    public static void main(String[] args) {
        for(int i=STARTFILE;i&amp;lt;ENDFILE;i++){
            Thread thread = new Thread(new MaxNumOfYearTest(i));
            thread.start();
        }
    }
    public void run() {
        // TODO Auto-generated method stub
        File file = new File(&amp;quot;C:\\Users\\Administrator\\Desktop\\笔记\\testdata\\test&amp;quot;+num+&amp;quot;.txt&amp;quot;);
        FileWriter b =null;
        try {
            b= new FileWriter(file);
            for(int i = 0;i&amp;lt;ONEFILEMAXLINE;i++){
                int randomYear = 1900 + (int)(Math.random()*100);
                int randomNum = (int)(Math.random()*100);
                b.write(randomYear+&amp;quot; &amp;quot;+randomNum+&amp;quot;\n&amp;quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(e);
        }finally{
            try {
                b.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是对应的源码&lt;/p&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;project xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot;  
     xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;quot;&amp;gt;  
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;  
    &amp;lt;groupId&amp;gt;com.jellygogo.ToolTest&amp;lt;/groupId&amp;gt;  
    &amp;lt;artifactId&amp;gt;ToolTest&amp;lt;/artifactId&amp;gt;  
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;    
    &amp;lt;name&amp;gt;ToolTest&amp;lt;/name&amp;gt;  
    &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;  
    &amp;lt;properties&amp;gt;  
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;  
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;hadoop-common&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;hadoop-hdfs&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;hadoop-client&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;4.10&amp;lt;/version&amp;gt;  
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;  
        &amp;lt;/dependency&amp;gt;  

        &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.mrunit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mrunit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.9.0-incubating&amp;lt;/version&amp;gt;
        &amp;lt;classifier&amp;gt;hadoop2&amp;lt;/classifier&amp;gt; 
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;  
    &amp;lt;version&amp;gt;3.0&amp;lt;/version&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.3&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ToolTest.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.jellygogo.hadoop;    
import java.io.IOException;    
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapred.JobConf;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Partitioner;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;    
public class ToolTest extends Configured implements Tool {        
    public int run(String[] arg0) throws Exception {
        Job job = Job.getInstance(getConf());
        job.setJarByClass(ToolTest.class);
        job.setInputFormatClass(TextInputFormat.class);
        job.setOutputFormatClass(TextOutputFormat.class);    
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);
        FileInputFormat.setInputPaths(job, new Path(arg0[0]));
        FileOutputFormat.setOutputPath(job, new Path(arg0[1]));
        job.setMapperClass(MapperTest.class);
        job.setReducerClass(ReduceTest.class);
        job.setCombinerClass(CTest.class);
        job.setNumReduceTasks(5);
        job.setPartitionerClass(MyPartitioner.class);
        if (job.waitForCompletion(true))
            return 0;
        else
            return 1;
    }
    public static void main(String[] args) {
        Configuration configuration = new Configuration();
        try {
            ToolRunner.run(new ToolTest(), args);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(e);
        }
    }
}
class ReduceTest extends Reducer&amp;lt;Text, Text, Text, Text&amp;gt; {
    protected void reduce(Text arg0, Iterable&amp;lt;Text&amp;gt; arg1, Reducer&amp;lt;Text, Text, Text, Text&amp;gt;.Context arg2)
            throws IOException, InterruptedException {
        int max = 0;
        for (Text t : arg1) {
            String intString = t.toString();
            int thisvalue = Integer.valueOf(intString);
            if (thisvalue &amp;gt; max)
                max = thisvalue;
        }
        arg2.write(arg0, new Text(max + &amp;quot;&amp;quot;));
    }
}
class MapperTest extends Mapper&amp;lt;LongWritable, Text, Text, Text&amp;gt; {
    protected void map(LongWritable key, Text value, Mapper&amp;lt;LongWritable, Text, Text, Text&amp;gt;.Context context)
            throws IOException, InterruptedException {
        String v = value.toString();
        if (v != null &amp;amp;&amp;amp; v.length() &amp;gt; 5) {
            context.write(new Text(value.toString().substring(0, 4)),
                    new Text(value.toString().substring(5, v.length())));
        }
    }
}
class CTest extends Reducer&amp;lt;Text, Text, Text, Text&amp;gt; {
    protected void reduce(Text arg0, Iterable&amp;lt;Text&amp;gt; arg1, Reducer&amp;lt;Text, Text, Text, Text&amp;gt;.Context arg2)
            throws IOException, InterruptedException {
        int max = 0;
        for (Text t : arg1) {
            String intString = t.toString();
            int thisvalue = Integer.valueOf(intString);
            if (thisvalue &amp;gt; max)
                max = thisvalue;
        }
        arg2.write(arg0, new Text(max + &amp;quot;&amp;quot;));
    }
}

class MyPartitioner extends Partitioner{
    public int getPartition(Object key, Object value, int numPartitions) {
        // TODO Auto-generated method stub
        int result = 0;
        if (key.toString().startsWith(&amp;quot;1&amp;quot;)) {  
            result = 0 % numPartitions;  
        } else if (key.toString().startsWith(&amp;quot;2&amp;quot;)) {  
            result = 1 % numPartitions;  
        }else {
            result = 3 % numPartitions; 
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MR2Test.java&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.jellygogo.hadoop;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mrunit.mapreduce.MapDriver;
import org.apache.hadoop.mrunit.mapreduce.MapReduceDriver;
import org.apache.hadoop.mrunit.mapreduce.ReduceDriver;
import org.apache.hadoop.mrunit.types.Pair;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import junit.framework.TestCase;
public class MR2Test extends TestCase{

    private Mapper&amp;lt;LongWritable, Text, Text, Text&amp;gt; mapper;
    private Reducer reducer;
    private MapDriver&amp;lt;LongWritable, Text, Text, Text&amp;gt; mapDirver;
    private ReduceDriver reduceDirver;
    private MapReduceDriver rdDirver; 
    @Test
    public void testMap(){
        mapper = new MapperTest();
        reducer = new ReduceTest();
        mapDirver = new MapDriver&amp;lt;&amp;gt;(mapper);
        reduceDirver = new ReduceDriver&amp;lt;&amp;gt;(reducer);
        rdDirver = new MapReduceDriver&amp;lt;&amp;gt;(mapper, reducer);
        mapDirver.withInput(new LongWritable(1L), new Text(&amp;quot;1995 56&amp;quot;));
        mapDirver.withOutput( new Text(&amp;quot;1995&amp;quot;), new Text(&amp;quot;56&amp;quot;));
        mapDirver.runTest();
    }
    @Test
    public void testReduceOneValue(){
        mapper = new MapperTest();
        reducer = new ReduceTest();
        mapDirver = new MapDriver&amp;lt;&amp;gt;(mapper);
        reduceDirver = new ReduceDriver&amp;lt;&amp;gt;(reducer);
        rdDirver = new MapReduceDriver&amp;lt;&amp;gt;(mapper, reducer);
        List&amp;lt;Text&amp;gt; list = new ArrayList&amp;lt;Text&amp;gt;();
        list.add(new Text(&amp;quot;1&amp;quot;));
        list.add(new Text(&amp;quot;5&amp;quot;));
        list.add(new Text(&amp;quot;4&amp;quot;));
        reduceDirver.withInput(new Text(&amp;quot;1995&amp;quot;), list);
        reduceDirver.withOutput( new Text(&amp;quot;1995&amp;quot;), new Text(&amp;quot;5&amp;quot;));
//        try {
//            List&amp;lt;Pair&amp;gt; l = reduceDirver.run();
//            System.out.println(&amp;quot;testReduceOneValue=====&amp;quot;);
//            for(Pair o:l)
//                System.out.println(o);
//        } catch (IOException e) {
//            // TODO Auto-generated catch block
//            e.printStackTrace();
//        }
    }
    @Test
    public void testMapReduce(){
        mapper = new MapperTest();
        reducer = new ReduceTest();
        mapDirver = new MapDriver&amp;lt;&amp;gt;(mapper);
        reduceDirver = new ReduceDriver&amp;lt;&amp;gt;(reducer);
        rdDirver = new MapReduceDriver&amp;lt;&amp;gt;(mapper, reducer);
        rdDirver.withInput(new LongWritable(1L), new Text(&amp;quot;1995 5&amp;quot;));
        rdDirver.withInput(new LongWritable(2L), new Text(&amp;quot;1995 6&amp;quot;));
        rdDirver.withInput(new LongWritable(3L), new Text(&amp;quot;1996 10&amp;quot;));
        rdDirver.withInput(new LongWritable(5L), new Text(&amp;quot;1996 1&amp;quot;));
        rdDirver.withInput(new LongWritable(6L), new Text(&amp;quot;1994 100&amp;quot;));
        rdDirver.withInput(new LongWritable(7L), new Text(&amp;quot;1996 2&amp;quot;));
        rdDirver.withOutput( new Text(&amp;quot;1994&amp;quot;), new Text(&amp;quot;100&amp;quot;));
        rdDirver.withOutput( new Text(&amp;quot;1995&amp;quot;), new Text(&amp;quot;6&amp;quot;));
        rdDirver.withOutput( new Text(&amp;quot;1996&amp;quot;), new Text(&amp;quot;10&amp;quot;));
//        withoutput应该按照key排序输入
//        (1994, 100)
//        (1995, 6)
//        (1996, 10)
        rdDirver.runTest();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一次测试时,没有加job.setCombinerClass(CTest.class) 这一句,没有使用combiner&lt;br&gt;得出结果如下:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Map-Reduce Framework&lt;br&gt;               Map input records=100000&lt;br&gt;               Map output records=100000&lt;br&gt;               Map output bytes=789913&lt;br&gt;               Map output materialized bytes=989925&lt;br&gt;               Input split bytes=103&lt;br&gt;               Combine input records=0&lt;br&gt;               Combine output records=0&lt;br&gt;               Reduce input groups=100&lt;br&gt;               Reduce shuffle bytes=989925&lt;br&gt;               Reduce input records=100000&lt;br&gt;               Reduce output records=100&lt;br&gt;               Spilled Records=200000&lt;br&gt;               Shuffled Maps =2&lt;br&gt;               Failed Shuffles=0&lt;br&gt;               Merged Map outputs=2&lt;br&gt;               GC time elapsed (ms)=487&lt;br&gt;               CPU time spent (ms)=6770&lt;br&gt;               Physical memory (bytes) snapshot=383012864&lt;br&gt;               Virtual memory (bytes) snapshot=6227005440&lt;br&gt;               Total committed heap usage (bytes)=157134848&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用combiner之后&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Map-Reduce Framework&lt;br&gt;             Map input records=100000&lt;br&gt;             Map output records=100000&lt;br&gt;             Map output bytes=789913&lt;br&gt;             Map output materialized bytes=1012&lt;br&gt;             Input split bytes=103&lt;br&gt;             Combine input records=100000&lt;br&gt;             Combine output records=100&lt;br&gt;             Reduce input groups=100&lt;br&gt;             Reduce shuffle bytes=1012&lt;br&gt;             Reduce input records=100&lt;br&gt;             Reduce output records=100&lt;br&gt;             Spilled Records=200&lt;br&gt;             Shuffled Maps =2&lt;br&gt;             Failed Shuffles=0&lt;br&gt;             Merged Map outputs=2&lt;br&gt;             GC time elapsed (ms)=444&lt;br&gt;             CPU time spent (ms)=4860&lt;br&gt;             Physical memory (bytes) snapshot=392232960&lt;br&gt;             Virtual memory (bytes) snapshot=6227005440&lt;br&gt;             Total committed heap usage (bytes)=156102656&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以对比出&lt;br&gt;                Combine input records=0&lt;br&gt;                Combine output records=0&lt;br&gt;与&lt;br&gt;                Combine input records=100000&lt;br&gt;                Combine output records=100&lt;/p&gt;
&lt;p&gt;Combiner相关链接 &lt;a href=&quot;http://www.tuicool.com/articles/qAzUjav&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/qAzUjav&lt;/a&gt;&lt;br&gt;partitioner相关链接 &lt;a href=&quot;http://www.cnblogs.com/xwdreamer/archive/2011/10/27/2296943.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/xwdreamer/archive/2011/10/27/2296943.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在maven中使用MRunit测试框架搭建了个mapreduce程序,里面使用了combiner和partitioner&lt;br&gt;并使用了 org.apache.hadoop.util.Tool&lt;br&gt;实现了找出对应年份的最大值,&lt;br&gt;        //数据样例&lt;br&gt; 
    
    </summary>
    
    
      <category term="hadoop" scheme="http://jellygogo.com/tags/hadoop/"/>
    
      <category term="mapreduce" scheme="http://jellygogo.com/tags/mapreduce/"/>
    
      <category term="combiner" scheme="http://jellygogo.com/tags/combiner/"/>
    
      <category term="partitioner" scheme="http://jellygogo.com/tags/partitioner/"/>
    
      <category term="MRunit" scheme="http://jellygogo.com/tags/MRunit/"/>
    
      <category term="Tool" scheme="http://jellygogo.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>常用java类源码初窥</title>
    <link href="http://jellygogo.com/2016/03/31/%E5%B8%B8%E7%94%A8java%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%9D%E7%AA%A5/"/>
    <id>http://jellygogo.com/2016/03/31/常用java类源码初窥/</id>
    <published>2016-03-31T13:54:00.000Z</published>
    <updated>2016-04-03T09:03:20.356Z</updated>
    
    <content type="html">&lt;p&gt;包括内容:java常用类源码,java源码中常用数据结构&lt;br&gt;此篇博客用来记录我对java基础在源码上面的认识,不定时填坑&lt;/p&gt;
&lt;h1 id=&quot;1-List系列&quot;&gt;&lt;a href=&quot;#1-List系列&quot; class=&quot;headerlink&quot; title=&quot;1.List系列&quot;&gt;&lt;/a&gt;1.List系列&lt;/h1&gt;&lt;p&gt;List系列常用的实现类是LinkedList和ArrayList&lt;/p&gt;
&lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;p&gt;内部使用一个数组来实现List&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;private transient Object[] elementData;&lt;/p&gt;
&lt;p&gt;Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想&lt;br&gt;用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。&lt;br&gt;transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的&lt;br&gt;转自:&lt;a href=&quot;http://www.blogjava.net/fhtdy2004/archive/2009/06/20/286112.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.blogjava.net/fhtdy2004/archive/2009/06/20/286112.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ArrayList中插入一个元素需要将此元素后面的都往后移动,&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;public void add(int index, E element) {&lt;br&gt;        rangeCheckForAdd(index);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于System.arraycopy()  &lt;a href=&quot;http://xuyuanshuaaa.iteye.com/blog/1046621&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xuyuanshuaaa.iteye.com/blog/1046621&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ArrayList中删除元素时,并不会将内部的elementData变小&lt;/p&gt;
&lt;/blockquote&gt;&lt;/p&gt;
&lt;h2 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h2&gt;&lt;p&gt;内部使用内部对象存储,&lt;br&gt;public class LinkedList&lt;e&gt;&lt;br&gt;    extends AbstractSequentialList&lt;e&gt;&lt;br&gt;    implements List&lt;e&gt;, Deque&lt;e&gt;, Cloneable, java.io.Serializable&lt;/e&gt;&lt;/e&gt;&lt;/e&gt;&lt;/e&gt;&lt;/p&gt;
&lt;p&gt;如果有大量随机访问对象的需求,就使用ArrayList,如果有大量插入删除使用LinkedList&lt;/p&gt;
&lt;h1 id=&quot;2-Map系列&quot;&gt;&lt;a href=&quot;#2-Map系列&quot; class=&quot;headerlink&quot; title=&quot;2.Map系列&quot;&gt;&lt;/a&gt;2.Map系列&lt;/h1&gt;&lt;p&gt;几个常用Map实现类:HashMap TreeMap LinkedHashMap ConcurrentHashMap&lt;/p&gt;
&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;p&gt; 使用数组和链表实现,在HashMap中使用一个数组,内部的hash()计算出hash值一样的数放入同一个Entry中,Entry中使用链表存储&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
 static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final K key;
    V value;
    Entry&amp;lt;K,V&amp;gt; next;
    int hash;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HashMap其实就是一个Entry数组，Entry对象中包含了键和值，其中next也是一个Entry对象，它就是用来处理hash冲突的，形成一个链表。&lt;/p&gt;
&lt;p&gt;关于HashMap很贴切的解释 &lt;a href=&quot;http://www.cnblogs.com/ITtangtang/p/3948406.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/ITtangtang/p/3948406.html&lt;/a&gt; 包含loadFactor加载因子的内容&lt;/p&gt;
&lt;h2 id=&quot;TreeMap&quot;&gt;&lt;a href=&quot;#TreeMap&quot; class=&quot;headerlink&quot; title=&quot;TreeMap&quot;&gt;&lt;/a&gt;TreeMap&lt;/h2&gt;&lt;p&gt;Tree内部使用二叉树(红黑树)来存储key-value&lt;br&gt;(先开个坑,有空再填)&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/26668941&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/26668941&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;LinkedHashMap&quot;&gt;&lt;a href=&quot;#LinkedHashMap&quot; class=&quot;headerlink&quot; title=&quot;LinkedHashMap&quot;&gt;&lt;/a&gt;LinkedHashMap&lt;/h2&gt;&lt;p&gt;LinkedHashMap继承自HashMap,在HashMap基础上面增加了TreeMap的顺序输出功能,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Entry中,增加了next
static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final K key;
    V value;
    Entry&amp;lt;K,V&amp;gt; next;
    int hash;
}
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);//&amp;lt;----------
            return oldValue;
        }
    }

    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
//LinkedHashMap中重载了recordAccess这个方法.
//recordAccess中标记了
    void recordAccess(HashMap&amp;lt;K,V&amp;gt; m) {
        LinkedHashMap&amp;lt;K,V&amp;gt; lm = (LinkedHashMap&amp;lt;K,V&amp;gt;)m;
        if (lm.accessOrder) {
            lm.modCount++;
            remove();
            addBefore(lm.header);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h2&gt;&lt;p&gt;这是一个线程安全的HashMap,在Collection中也提供了线程安全类&lt;br&gt;    public static &lt;k,v&gt; Map&lt;k,v&gt; synchronizedMap(Map&lt;k,v&gt; m) {&lt;br&gt;        return new SynchronizedMap&lt;k,v&gt;(m);&lt;br&gt;     }&lt;br&gt;SynchronizedMap中所有的方法都加上了synchronized,保证了方法的同步,但在使用中仍然会有安全问题&lt;br&gt;ConcurrentHashMap中使用了,锁分段技术具体细节刨个坑,以后再填&lt;/k,v&gt;&lt;/k,v&gt;&lt;/k,v&gt;&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/madun/article/details/6326337&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/madun/article/details/6326337&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于HashMap和hashTable&quot;&gt;&lt;a href=&quot;#关于HashMap和hashTable&quot; class=&quot;headerlink&quot; title=&quot;关于HashMap和hashTable &quot;&gt;&lt;/a&gt;关于HashMap和hashTable &lt;/h2&gt;&lt;p&gt;HashMap中key和value都可以是null,而在hashtable中key和value都不能是null&lt;br&gt;hashtable是线程安全的,但是效率低下,全局使用了一把锁,当其他线程访问时,容易堵塞&lt;/p&gt;
&lt;h2 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h2&gt;&lt;p&gt;Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)  &lt;a href=&quot;http://www.chawenti.com/articles/20110.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chawenti.com/articles/20110.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2016-4-3 参考书籍:java程序员成功面试秘籍(书名感觉挺low的,但是里面还是有一定东西的)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;包括内容:java常用类源码,java源码中常用数据结构&lt;br&gt;此篇博客用来记录我对java基础在源码上面的认识,不定时填坑&lt;/p&gt;
&lt;h1 id=&quot;1-List系列&quot;&gt;&lt;a href=&quot;#1-List系列&quot; class=&quot;headerlink&quot; title=&quot;1.List
    
    </summary>
    
    
      <category term="java" scheme="http://jellygogo.com/tags/java/"/>
    
      <category term="源码" scheme="http://jellygogo.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据结构" scheme="http://jellygogo.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop气象数据下载小程序</title>
    <link href="http://jellygogo.com/2016/03/17/Hadoop%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://jellygogo.com/2016/03/17/Hadoop气象数据下载小程序/</id>
    <published>2016-03-17T14:18:26.000Z</published>
    <updated>2016-03-17T14:41:22.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Hadoop气象数据下载小程序&quot;&gt;&lt;a href=&quot;#Hadoop气象数据下载小程序&quot; class=&quot;headerlink&quot; title=&quot;Hadoop气象数据下载小程序&quot;&gt;&lt;/a&gt;Hadoop气象数据下载小程序&lt;/h1&gt;&lt;h2 id=&quot;写小程序的原因&quot;&gt;&lt;a href=&quot;#写小程序的原因&quot; class=&quot;headerlink&quot; title=&quot;写小程序的原因&quot;&gt;&lt;/a&gt;写小程序的原因&lt;/h2&gt;&lt;p&gt;在学习Hadoop学习指南时,遇到了&lt;a href=&quot;ftp://www1.ncdc.noaa.gov/pub/data/noaa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ftp&lt;/a&gt;下载链接不能下载的原因,于是去找&lt;a href=&quot;http://www1.ncdc.noaa.gov/pub/data/noaa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http下载&lt;/a&gt;的链接,但是使用迅雷批量下载时遇到了文件限制,在每个年份的文件夹下大约有1W-3W个文件,但是迅雷批量下载一次只能下载1000个连接,遂自己写了短代码,来自己下载&lt;/p&gt;
&lt;p&gt;顺便这段时间再看代码整洁之道,我试下尽我所能写出书什么样的代码&lt;/p&gt;
&lt;h2 id=&quot;java代码&quot;&gt;&lt;a href=&quot;#java代码&quot; class=&quot;headerlink&quot; title=&quot;java代码&quot;&gt;&lt;/a&gt;java代码&lt;/h2&gt;&lt;p&gt;现在还才刚开始学习Python,过段时间会来再用Python代码实现下这个功能&lt;br&gt;重新需要输入一个在1970-2016之间的数字来下载某一年的数据,因为我不需要太多的数据,所以这样设计的.&lt;/p&gt;
&lt;p&gt;关于线程池的选择&lt;br&gt;&lt;a href=&quot;http://coach.iteye.com/blog/855850&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;线程池的使用&lt;/a&gt; &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public class NcdcFileDownload &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final static String  HTTPURL = &amp;quot;http://www1.ncdc.noaa.gov/pub/data/noaa/&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private final static String ROOTFOLDER = &amp;quot;D://filedowntest//&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 public static void main(String[] args) throws Exception  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 	int year = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 	Scanner scanner = new Scanner(System.in);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		 	year = scanner.nextInt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        // 创建HttpClient实例     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        HttpClient httpclient = new DefaultHttpClient(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        // 创建Get方法实例     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        HttpGet httpgets = new HttpGet(HTTPURL+year+&amp;quot;/&amp;quot;);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        HttpResponse response = httpclient.execute(httpgets);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        HttpEntity entity = response.getEntity(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        // 存储这一年每个气象数据的url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        HashSet&amp;lt;String&amp;gt; httpDownLoadURL = new HashSet&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        if (entity != null) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            InputStream instreams = entity.getContent();    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            //获取这一页的HTML代码,从中提取带有 -XXXX.gz的url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            String responseHTMLInformation = convertStreamToString(instreams);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            String[] allHttpDownLoadURL = responseHTMLInformation.split(&amp;quot;-&amp;quot;+year+&amp;quot;.gz&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            HttpDownload httpDownload = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            //去除错误与重复的url,并放在httpDownLoadURL中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            for(String tmp:allHttpDownLoadURL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	if(tmp!=null&amp;amp;&amp;amp;tmp.length()&amp;gt;13)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		            	tmp = tmp.substring(tmp.length()-12)+&amp;quot;-2015.gz&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		            	if(tmp!=null&amp;amp;&amp;amp;tmp.length()==20)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		            		httpDownLoadURL.add(tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		            	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            int downLoadTaskNum = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            ThreadPoolExecutor executor = new ThreadPoolExecutor(20, 30, 10,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            		TimeUnit.SECONDS, new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(10000),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            		new ThreadPoolExecutor.DiscardOldestPolicy());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            for(String tmp:httpDownLoadURL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	downLoadTaskNum++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	File createFolder = new File(ROOTFOLDER+year);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	createFolder.mkdir();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	httpDownload = new HttpDownload();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	httpDownload.setUrl(HTTPURL+year+&amp;quot;/&amp;quot;+tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	httpDownload.setPath(ROOTFOLDER+year+&amp;quot;//&amp;quot;+tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	httpDownload.setI(downLoadTaskNum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            	executor.execute(httpDownload);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	           httpgets.abort();    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		public static String convertStreamToString(InputStream is) &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        BufferedReader reader = new BufferedReader(new InputStreamReader(is));      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        StringBuilder sb = new StringBuilder();      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        String line = null;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        try &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            while ((line = reader.readLine()) != null) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	                sb.append(line + &amp;quot;\n&amp;quot;);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125; catch (IOException e) &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            e.printStackTrace();      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125; finally &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            try &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	                is.close();      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125; catch (IOException e) &amp;#123;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	               e.printStackTrace();      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	            &amp;#125;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &amp;#125;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        return sb.toString();      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下载文件的类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HttpDownload implements Runnable{
public  final int cache = 10 * 1024;
public  final boolean isWindows;
public  final String splash;
public  final String root;
private String url;
private String path;
private int i;

 public int getI() {
    return i;
}
public void setI(int i) {
    this.i = i;
}

{
    if (System.getProperty(&amp;quot;os.name&amp;quot;) != null &amp;amp;&amp;amp; System.getProperty(&amp;quot;os.name&amp;quot;).toLowerCase().contains(&amp;quot;windows&amp;quot;)) {
        isWindows = true;
        splash = &amp;quot;\\&amp;quot;;
        root=&amp;quot;D:&amp;quot;;
    } else {
        isWindows = false;
        splash = &amp;quot;/&amp;quot;;
        root=&amp;quot;/search&amp;quot;;
    }
}


public  String download() {
    try {
        HttpClient client = new DefaultHttpClient();
        HttpGet httpget = new HttpGet(url);
        HttpResponse response = client.execute(httpget);

        HttpEntity entity = response.getEntity();
        InputStream is = entity.getContent();
        if (path == null)
            path = getFilePath(response);
        File file = new File(path);
        file.getParentFile().mkdirs();
        FileOutputStream fileout = new FileOutputStream(file);
        /**
         * 根据实际运行效果 设置缓冲区大小
         */
        byte[] buffer=new byte[cache];
        int ch = 0;
        while ((ch = is.read(buffer)) != -1) {
            fileout.write(buffer,0,ch);
        }
        is.close();
        fileout.flush();
        fileout.close();

    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public  String getFilePath(HttpResponse response) {
    String filepath = root + splash;
    String filename = getFileName(response);

    if (filename != null) {
        filepath += filename;
    } else {
        filepath += getRandomFileName();
    }
    return filepath;
}

public  String getFileName(HttpResponse response) {
    Header contentHeader = response.getFirstHeader(&amp;quot;Content-Disposition&amp;quot;);
    String filename = null;
    if (contentHeader != null) {
        HeaderElement[] values = contentHeader.getElements();
        if (values.length == 1) {
            NameValuePair param = values[0].getParameterByName(&amp;quot;filename&amp;quot;);
            if (param != null) {
                try {
                    filename = param.getValue();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
    return filename;
}
/**
 * 获取随机文件名
 * @return
 */
public  String getRandomFileName() {
    return String.valueOf(System.currentTimeMillis());
}
public  void outHeaders(HttpResponse response) {
    Header[] headers = response.getAllHeaders();
    for (int i = 0; i &amp;lt; headers.length; i++) {
        System.out.println(headers[i]);
    }
}

@Override
public void run() {
    // TODO Auto-generated method stub
    try{
    download();
        System.out.println(&amp;quot;task&amp;quot;+this.i+&amp;quot;--&amp;quot;+this.url+&amp;quot;------100% SUCCESS&amp;quot;);
    }catch(Exception e){
        System.out.println(&amp;quot;task&amp;quot;+this.i+&amp;quot;--&amp;quot;+this.url+&amp;quot;------0% FAIL !!!!!!!!!!!!!!!!!!!!!!&amp;quot;);
    }

}

public String getUrl() {
    return url;
}

public void setUrl(String url) {
    this.url = url;
}

public String getPath() {
    return path;
}

public void setPath(String path) {
    this.path = path;
}

public int getCache() {
    return cache;
}

public boolean isWindows() {
    return isWindows;
}

public String getSplash() {
    return splash;
}

public String getRoot() {
    return root;
}


}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop气象数据下载小程序&quot;&gt;&lt;a href=&quot;#Hadoop气象数据下载小程序&quot; class=&quot;headerlink&quot; title=&quot;Hadoop气象数据下载小程序&quot;&gt;&lt;/a&gt;Hadoop气象数据下载小程序&lt;/h1&gt;&lt;h2 id=&quot;写小程序的原因&quot;&gt;&lt;a h
    
    </summary>
    
    
      <category term="java" scheme="http://jellygogo.com/tags/java/"/>
    
      <category term="Hadoop" scheme="http://jellygogo.com/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://jellygogo.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>转移到github的第一篇博客</title>
    <link href="http://jellygogo.com/2016/03/16/%E8%BD%AC%E7%A7%BB%E5%88%B0github%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://jellygogo.com/2016/03/16/转移到github的第一篇博客/</id>
    <published>2016-03-16T09:56:10.000Z</published>
    <updated>2016-03-16T14:41:22.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;h2 id=&quot;以前的故事&quot;&gt;&lt;a href=&quot;#以前的故事&quot; class=&quot;headerlink&quot; title=&quot;以前的故事&quot;&gt;&lt;/a&gt;以前的故事&lt;/h2&gt;&lt;p&gt;以前也在csdn写过博客,都是一些学习笔记之类的东西,断断续续的写了一段时间,这期间伴随我学习spring源码,高性能MySQL等一些东西,期间慢慢接触到github这个东东,虽然感觉很神奇但是苦于英文疲软,一直没敢开这个坑.现在慢慢的接触开源项目越来越多,不得不接触她((✿◡‿◡))了,这次使用github也算是对github的入门了.&lt;/p&gt;
&lt;h2 id=&quot;现在的打算&quot;&gt;&lt;a href=&quot;#现在的打算&quot; class=&quot;headerlink&quot; title=&quot;现在的打算&quot;&gt;&lt;/a&gt;现在的打算&lt;/h2&gt;&lt;p&gt;发现自己不完善的地方很多,自我感觉很差,下面列举下目前感觉到的缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基础知识不好,特别是算法基础(全心专注外功,没有好好修炼过内功)&lt;br&gt;英文能力差,阅读github的 &lt;a href=&quot;https://guides.github.com/activities/hello-world/&quot; title=&quot;hello world链接&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;helloworld&lt;/a&gt;的文档都不流畅,上面写10分钟读完的,我tm快读了20分钟&lt;br&gt;懒,间歇性懒癌&lt;br&gt;选择性遗忘症&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;以后的打算&quot;&gt;&lt;a href=&quot;#以后的打算&quot; class=&quot;headerlink&quot; title=&quot;以后的打算&quot;&gt;&lt;/a&gt;以后的打算&lt;/h2&gt;&lt;p&gt;现在是大三了,还有一年半毕业,是时候要为自己的就业做打算了,目前我学习的重点是大数据研发,愿与君共勉&lt;/p&gt;
&lt;p&gt;博客写作计划:每周至少用心写一篇,坚持最难得,希望我能坚持下去(怀疑)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;h2 id=&quot;以前的故事&quot;&gt;&lt;a href=&quot;#以前的故事&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
    
      <category term="闲话扯淡" scheme="http://jellygogo.com/tags/%E9%97%B2%E8%AF%9D%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
</feed>
